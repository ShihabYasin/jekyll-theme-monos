---
layout: post
title: Python-Dataclass-Decorator
date: 2019-02-16 16:20:23 +0900
category: Python
tag: Python
---

<head>

</head>

<body>

<header>

</header>

<div class="container">



<div class="content">

<h1>Python Dataclass Decorator.</h1>

<p>
The <code>dataclass</code> decorator is used to automatically generate special methods to classes,
including <code>__str__</code> and <code>__repr__</code>. It helps reduce some boilerplate
code. The <code>dataclass</code> decorator is located in the <code>dataclasses</code> module.
</p>



<p>
The <code>dataclass</code> decorator examines the class to find fields. A field
is defined as class variable that has a type annotation.
</p>

<pre class="compact">
@dataclass
class Test:
...

@dataclass()
class Test:
...

@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)
class Test:
...
</pre>

<p>
These three declarations are equivalent. If no parameters are set in the
decorator, the default ones are used. If the <code>init</code> parameter is set
to <code>True</code>, the <code>__init__</code> method will be generated. If
the class already defines the <code>__init__</code>, the parameter is ignored.
If the <code>repr</code> parameter is set to <code>True</code>, the
<code>__repr__</code> method will be generated. If the class already defines
the <code>__repr__</code>, the parameter is ignored. If the <code>eq</code>
parameter is set to <code>True</code>, the <code>__eq__</code> method will be
generated. If the class already defines <code>__eq__</code>, this parameter is
ignored.
</p>

<p>
If the <code>order</code> parameter is set to <code>True</code>, the
<code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, and
<code>__ge__</code> methods are generated. If the class already defines
any of the methods, the <code>ValueError</code> is raised.
If the <code>unsafe_hash</code> is defined to <code>False</code>,
the <code>__hash__</code> method is generated according
to how <code>eq</code> and <code>frozen</code> are set. If the <code>frozen</code>
parameter is set to <code>True</code>, the assignment to fields will generate an
exception.
</p>


<h2>Python regular custom class</h2>

<p>
In a regular custom Python class, we provide a constructor
and other methods such as <code>__repr__</code> manually.
</p>

<div class="codehead">regular_class.py</div>

<pre class="code">
{% raw %}
#!/usr/bin/env python
class Person:
def __init__(self, name, age):
self.name = name
self.age = age
def __repr__(self):
return f'Person{{name: {self.name}, age: {self.age}}}'
p = Person('John Doe', 34)
print(p)
{% endraw %}
</pre>

<p>
The example shows a <code>Person</code> class with a constructor and
the <code>__repr__</code> method, which gives a complete representation
of the object.
</p>

<pre class="compact">
$ ./regular_class.py
Person{name: John Doe, age: 34}
</pre>



<h2>Python dataclass example</h2>

<p>
The following example shows a simple usage of the
<code>dataclass</code> decorator.
</p>

<div class="codehead">simple_dataclass.py</div>
<pre class="code">
#!/usr/bin/env python

from dataclasses import dataclass

@dataclass
class Person:
name: str
age: int

p = Person('John Doe', 34)
print(p)
</pre>

<p>
We have a class with two fields: <code>name</code> and <code>str</code>.
</p>

<pre class="explanation">
from dataclasses import dataclass
</pre>

<p>
The <code>dataclass</code> decorator is located in the <code>dataclasses</code>
module.
</p>

<pre class="explanation">
@dataclass
class Person:
name: str
age: int
</pre>

<p>
We apply the <code>dataclass</code> decorator on the <code>Person</code>
class.
</p>

<pre class="explanation">
p = Person('John Doe', 34)
print(p)
</pre>

<p>
A new person object is created. Its <code>__init__</code> method
is called, which is auto-generated by the <code>dataclass</code> decorator.
</p>

<pre class="compact">
$ ./simple_dataclass.py
Person(name='John Doe', age=34)
</pre>





<h2>Python dataclass default values</h2>

<p>
It is possible to provide default values to the fields.
</p>

<div class="codehead">default_values.py</div>
<pre class="code">
#!/usr/bin/env python

from dataclasses import dataclass

@dataclass
class Person:
name: str = 'unknown'
age: int = 0

p = Person('John Doe', 34)
print(p)

p2 = Person()
print(p2)
</pre>

<p>
In the example, the <code>Person</code> class has two fields; the
fields have some default values.
</p>

<pre class="explanation">
@dataclass
class Person:
name: str = 'unknown'
age: int = 0
</pre>

<p>
With the assignment operator (=), we give the fields default values.
</p>

<pre class="explanation">
p2 = Person()
print(p2)
</pre>

<p>
When we do not provide values in the constructor, the fields
will have default values.
</p>

<pre class="compact">
$ ./default_values.py
Person(name='John Doe', age=34)
Person(name='unknown', age=0)
</pre>



<h2>The dataclass frozen parameter</h2>

<p>
If the <code>frozen</code> parameter is set to <code>True</code>,
we cannot assign values to fields.
</p>

<div class="codehead">frozen.py</div>
<pre class="code">
#!/usr/bin/env python

from dataclasses import dataclass

@dataclass(frozen=True)
class Person:
name: str
age: int

p = Person('John Doe', 34)
p.occupation = 'gardener'

print(p)
print(p.occupation)
</pre>

<p>
In the example, the <code>frozen</code> parameter is set
to <code>True</code>. The program fails with the following error
message: <code>dataclasses.FrozenInstanceError: cannot assign to field 'occupation'</code>.
</p>


<h2>The dataclass asdict function</h2>

<p>
The <code>asdict</code> function converts a dataclass instance to a
dict of its fields.
</p>

<div class="codehead">as_dict_fun.py</div>
<pre class="code">
#!/usr/bin/env python

from dataclasses import dataclass, asdict

@dataclass
class Person:
name: str
occupation: str
age: int

p = Person('John Doe', 'gardener', 34)
print(p)

print(asdict(p))
</pre>

<p>
In the example, we print the fields of the <code>Person</code> class with
the help of the <code>asdict</code> function.
</p>

<pre class="compact">
$ ./as_dict_fun.py
Person(name='John Doe', occupation='gardener', age=34)
{'name': 'John Doe', 'occupation': 'gardener', 'age': 34}
</pre>

<p>
The first line is the output of the <code>__repr__</code> method.
The second line is the dictionary of the fields.
</p>


<h2>The dataclass field function</h2>

<p>
With the <code>field</code> function, we can provide
some additional per-field information.
</p>

<div class="codehead">fields.py</div>
<pre class="code">
#!/usr/bin/env python

from dataclasses import dataclass, field

@dataclass
class Person:
name: str
age: int
occupation: str = field(init=False, repr=False)

p = Person('John Doe', 34)
print(p)

p.occupation = "Gardener"
print(f'{p.name} is a {p.occupation}')
</pre>

<p>
In the example, we have an additional <code>occupation</code> field.
</p>

<pre class="explanation">
occupation: str = field(init=False, repr=False)
</pre>

<p>
The <code>occupation</code> field is not included in the <code>__init__</code>
and <code>__repr__</code> methods.
</p>

<pre class="compact">
$ ./fields.py
Person(name='John Doe', age=34)
John Doe is a Gardener
</pre>




</div> <!-- content -->

<div class="rtow">

</div>

</div> <!-- container -->

<footer>

</footer>

</body>

